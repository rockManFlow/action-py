package com.kuark.tool.advance.advance20191228;

/**
 * @author rock
 * @detail
 * @date 2020/4/23 15:15
 */
public class DubboResolver {
    /**
     * dubbo原理
     * 底层也是使用的socket连接方式
     *
     * 通信原理
     * 计算机想与外界交互，称为通信，基本通信有并行通信和串行通信
     * 并行通信：需要多条线路来满足并行通信，线路消耗比较大，适用于短距离的
     * 串行通信：仅需要一条线路，适用于长距离
     *
     * 串行通信按照通信方向分为3中
     * 单工：只能从一个方向往另外一个方向通信，反之不行
     * 半双工：两个方向都可以互相通信，但不能同时通信
     * 全双工：两个方向可以同时进行通信
     *
     * socket属于全双工
     * Socket 是一种应用接口, TCP/IP 是网络传输协议，虽然接口相同, 但是不同的协议会有不同的服务性质。
     * 创建Socket 连接时，可以指定使用的传输层协议，Socket 可以支持不同的传输层协议（TCP 或UDP ），
     * 当使用TCP 协议进行连接时，该Socket 连接就是一个TCP 连接。Soket 跟TCP/IP 并没有必然的联系。
     * Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。
     * 所以，socket 的出现只是可以更方便的使用TCP/IP 协议栈而已。
     *
     * Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。
     * Dubbo缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。
     *
     *     连接个数：单连接
     *     连接方式：长连接
     *     传输协议：TCP
     *     传输方式：NIO异步传输
     *     序列化：Hessian二进制序列化
     *     适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。
     *     适用场景：常规远程服务方法调用
     *
     * dubbo大体执行流程
     * 1， 客户端线程调用远程接口，向服务端发送请求，同时当前线程应该处于“暂停“状态，即线程不能向后执行了，必需要拿到服务端给自己的结果后才能向后执行
     *
     * 2， 服务端接到客户端请求后，处理请求，将结果给客户端
     *
     * 3， 客户端收到结果，然后当前线程继续往后执行
     *
     * 分析源代码，基本原理如下：
     *
     *     client一个线程调用远程接口，生成一个唯一的ID（比如一段随机字符串，UUID等），Dubbo是使用AtomicLong从0开始累计数字的
     *     将打包的方法调用信息（如调用的接口名称，方法名称，参数值列表等），和处理结果的回调对象callback，全部封装在一起，组成一个对象object
     *     向专门存放调用信息的全局ConcurrentHashMap里面put(ID, object)
     *     将ID和打包的方法调用信息封装成一对象connRequest，使用IoSession.write(connRequest)异步发送出去
     *     当前线程再使用callback的get()方法试图获取远程返回的结果，在get()内部，则使用synchronized获取回调对象callback的锁，
     *     再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。
     *     服务端接收到请求并处理后，将结果（此结果中包含了前面的ID，即回传）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，
     *     分析结果，取到ID，再从前面的ConcurrentHashMap里面get(ID)，从而找到callback，将方法调用结果设置到callback对象里。
     *     监听线程接着使用synchronized获取回调对象callback的锁（因为前面调用过wait()，那个线程已释放callback的锁了），
     *     再notifyAll()，唤醒前面处于等待状态的线程继续执行（callback的get()方法继续执行就能拿到调用结果了），至此，整个过程结束。
     *
     * 需要注意的是，这里的callback对象是每次调用产生一个新的，不能共享，否则会有问题；另外ID必需至少保证在一个Socket连接里面是唯一的。
     *
     *     当前线程怎么让它“暂停”，等结果回来后，再向后执行？
     *
     *      答：先生成一个对象obj，在一个全局map里put(ID,obj)存放起来，再用synchronized获取obj锁，再调用obj.wait()让当前线程处于等待状态，
     *      然后另一消息监听线程等到服务端结果来了后，
     *      再map.get(ID)找到obj，再用synchronized获取obj锁，再调用obj.notifyAll()唤醒前面处于等待状态的线程。
     *
     *     正如前面所说，Socket通信是一个全双工的方式，如果有多个线程同时进行远程方法调用，
     *     这时建立在client server之间的socket连接上会有很多双方发送的消息传递，前后顺序也可能是乱七八糟的，
     *     server处理完结果后，将结果消息发送给client，client收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？
     *
     *      答：使用一个ID，让其唯一，然后传递给服务端，再服务端又回传回来，这样就知道结果是原先哪个线程的了。
     *
     */
}
