详细学习Java.nio包中的知识
    标准的io是基于字节流和字符流进行的操作。nio是基于通道和缓冲区进行的操作。
    Java nio可以让你异步的使用io===？当通道读取数据到缓冲区时，线程还可以做其他的事情？？
    又引入了seletor选择器的概念，用于监听多个通道事件。

    ===详解===
    channel和buffer
    操作总是从channel中读取数据到buffer中，或者从buffer到channel
    主要实现：
    通道
        FileChannel                 //从文件中读写数据
        DatagramChannel             //能通过UDP读写网络中的数据
        SocketChannel               //能通过TCP读写网络中的数据
        ServerSocketChannel         //可以监听新进来的TCP连接，对于每个新进来的连接都会创建一个SocketChannel
        正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。
    buffer(实际上是一块封装的内存，提供了一些方法对这个内存进行操作)
        ByteBuffer
        CharBuffer
        DoubleBuffer
        FloatBuffer
        IntBuffer
        LongBuffer
        ShortBuffer
        这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。
    selector
        用于监听多个通道，在一个线程中。使用selector得向其注册channel，调用select方法

现在的问题是需要清楚怎么实现的
    看包中代码

nio的优势是：可以使用一个线程管理多个通道(网络中的一个线程多个连接)，通道有少量的数据交互，但会使解析数据更复杂。
             大量的数据交互使用io优势会更大一些
buffer的一些主要方法的解释
    capacity
    作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。
    position
    当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。
    当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0。当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。
    limit
    在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。
    当切换Buffer到读模式时， limit表示你最多能读到多少数据。
    clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面

selector的使用
    使用selector能够处理多个通道
    1.通过调用Selector.open()方法创建一个Selector
    2.向Selector注册通道
        例如：channel.configureBlocking(false);
              SelectionKey key = channel.register(selector,Selectionkey.OP_READ);//具体用法查资料和看文档