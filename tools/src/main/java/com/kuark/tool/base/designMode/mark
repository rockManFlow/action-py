设计模式：
1、装饰器模式:spring的aop也是通过装饰器模式实现的
    新的装饰器实现和旧的装饰器一样的接口，在新的中传入旧的对象，在指定位置封装新的功能


2、观察者模式：如果一个对象的状态改变需要通知其他对这个对象关注的一系列对象
    在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。
    这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。
    就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。
    具体实现：把需要通知的对象统一放到指定的集合中，当发生变化时，统一通知

3、简单工厂模式：核心是多个类拥有共同的接口，通过不同需求来创建不同的实现对象
    凡是出现了大量的产品需要创建，并且具有共同的接口时---工厂类(不好需要变更旧的代码)

4、抽象工厂类：公共的干活接口+公共的工厂类接口
    需要新增功能类，只要实现公共的干活接口，并且再实现创建这个干活接口的工厂类就行，不需要改变之前的代码

5、单利模式：只需要创建一个对象

6、建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

7、原型模式：思想就是将一个对象进行复制克隆，产生新的对象
    浅复制：将一个对象复制之后，基本数据类型都会重新创建，而引用类型还是指向之前的
    实现：可以使用object的clone方式来复制
    深复制：不管基本数据类型还是对象类型，都会进行重新复制
    实现：使用二进制流先读入当前对象，再使用输出流写出当前对象
        /* 写入当前对象的二进制流 */
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(this);

        /* 读出二进制流产生的新对象 */
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();

8、适配器模式：一个类想使用已存在类中的相关功能(要适配，消除相关差异)
    继承这个类，并实现一个接口(这个接口中包含继承这个类的相同方法名)---就可以直接用这个接口使用已存在的方法

9、代理模式：静态代理和装饰器模式挺相似，又进行了一次封装
    动态代理也叫作jdk代理，需要实现jdk中的接口

    spring的aop就可以通过动态代理和反射来实现

10、外观模式：定义了一个统一、高层的接口，外部通过这个统一的接口对子系统中的一群接口进行访问
    通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，
    客户端可以通过调用外观类的方法来调用内部子系统中所有方法。
    降低了外部与内部各个子系统之间的耦合度

11、模板方法模式：
    将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中

12、策略模式：
    具体使用地方的引用(上下文)、角色给出所有策略所需的接口(抽象)、各个策略接口的实现(具体)
    定义了一系列的算法，将每个算法封装起来，使他们可以相互替换，让算法独立于他的客户端而存在
    * 解决使用if else或case等问题,会涉及到策略的选择








